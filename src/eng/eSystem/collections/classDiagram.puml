@startuml

interface ICollection{
==_common_==
+<<default>>int count(Predicate<T> predicate)
+<<default>>int count()
+int size();

+boolean contains(T item);
==_checkers__==
+<<default>>boolean isAll(Predicate<T> predicate)
+<<default>>boolean isAny(Predicate<T> predicate)
+<<default>>boolean isEmpty()
+<<default>>boolean isNone(Predicate<T> predicate)
==_selectors_==
+<<default>>T getFirst(...)
+<<default>>T getLast(...)
+<<default>>T tryGetFirst(...)
+<<default>>T tryGetLast(...)
==_aggregators_==
+<<default>>T getMinimal(Selector<T, Double> minimizingCriterionSelector)
+<<default>>T getRandomByWeights(Selector<T, Double> weightSelector)
+<<default>>T getRandomByWeights(Selector<T, Double> weightSelector, Random rnd)

+<<default>><V extends Comparable<V>> T getSmallest(Selector<T, V> selector)
+<<default>><V extends Comparable<V>> T getGreatest(Selector<T, V> selector)


+<<default>><V> V aggregate(Selector<T, V> selector, BiFunction<V, V, V> aggregator, V initialAgregatorValue)
+<<default>><V extends Comparable<V>> V max(Selector<T, V> selector, V maximalValue)
+<<default>>double maxDouble(...)
+<<default>>int maxInt(...)
+<<default>>double mean(...)
+<<default>><V extends Comparable<V>> V min(Selector<T, V> selector, V minimalValue)
+<<default>>double minDouble(...)
+<<default>>int minInt(...)
+<<default>>double sumDouble(Selector<T, Double> selector)
+<<default>>int sumInt(Selector<T, Integer> selector)
+<<default>>long sumLong(Selector<T, Long> selector)
==_converters_==
+<<default>>T[] toArray(Class<T> arrayItemType)
+<<default>><K> K[] toArrayUnchecked(Class<K> arrayItemType)
+<<default>><K, V> IMap<K, V> toMap(Selector<T, K> keySelector, Selector<T, V> valueSelector)
+IList<T> toList();
+ISet<T> toSet();
}

interface IReadOnlySet

interface IReadOnlyList{
+<<default>> IList<T> distinct(...)
+T get(...)
+IReadOnlyList<T> getDuplicateItems()
+int getIndexOf(...)
+int getRandom()
+<IMap<K, IList<T>> groupBy(Selector<T,K> keySelector)
+IList<T> intersection(IReadOnlyList<T> otherList)
+IList<T> minus(IReadOnlyList<T> otherList)
+<K extends Comparable<K>> IList<T> orderBy(...)
+<V> IList<V> select(Selector<T, V> selector)
}

interface IList

class EList

class EDistinctList

class EObservableList

class ESet

ICollection <|-- IReadOnlyList
ICollection <|-- IReadOnlySet

IReadOnlyList <|-- IList
IList <|.. EList

IReadOnlySet <|-- ISet
isEmpty <|.. ESet

EList <|-- EDistinctList
EList <|-- EObservableList

@enduml
